## 偏离的工作

现在我们已经知道了如何从其它地方 `pull` 提交记录，以及如何 `push` 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？

困难来自于远程库提交历史的**偏离**。在讨论这个问题的细节前，我们先来看一个例子……

假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目**旧版**的代码，与远程仓库最新的代码不匹配了。

这种情况下, `git push` 就不知道该如何操作了。如果你执行 `git push`，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？

因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 `push` 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。



初始状态：

我的想法：这种情况下需要先拉取最新的代码，然后才能 `git push`，也就是说：`git push` 的前提是本地的远程 main 分支和远程仓库的 main 分支的状态需要保持一致才行

![image-20220630145231804](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630145231804.png)

![image-20220630145256372](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630145256372.png)



## 解决方案一

那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。

有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！

初始状态：

`git rebase o/main` 就是把当前所使用的分支指向的节点复制一份放在 `o/main` 分支所指向的节点下边

![image-20220630145446727](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630145446727.png)

C3' 的数据内容与 C3 是完全相同的，在这里代表是 C3 的复制品

![image-20220630145549680](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630145549680.png)





## 解决方案二

还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用 `merge`

尽管 `git merge` 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。

看下演示...

初始状态：

![image-20220630145744126](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630145744126.png)

执行后的结果：这个过程就相当于 `git pull` + `git push`

![image-20220630145825945](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630145825945.png)



很好！但是要敲那么多命令，有没有更简单一点的？

当然 —— 前面已经介绍过 `git pull` 就是 fetch 和 merge 的简写，类似的 `git pull --rebase` 就是 fetch 和 rebase 的简写！

让我们看看简写命令是如何工作的。



## 简写的命令 git pull --rebase 如何工作

初始状态：

![image-20220630145959474](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630145959474.png)

执行后的结果：使用 rebase 操作对 C3 进行复制然后放在 C2 的下边儿

![image-20220630150024286](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630150024286.png)



## 简写的命令 git pull 如何工作

初始状态：

![image-20220630150121192](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630150121192.png)

执行后的结果：常规的 pull 是使用合并（merge）的方式来完成的

![image-20220630150156452](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630150156452.png)



## 任务

由 fetch、rebase/merge 和 push 组成的工作流很普遍。后续课程我们会讲解更复杂的工作流，不过现在我们先解决这个关卡吧。

要完成本关，你需要完成以下几步：

- 克隆你的仓库
- 模拟一次远程提交（fakeTeamwork）
- 完成一次本地提交
- 用 *rebase* 发布你的工作



## 实现流程

1. 初始状态：

![image-20220630150508355](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630150508355.png)



2. 创建与本地仓库完全相同的远程仓库：

![image-20220630150531326](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630150531326-16565727626181.png)



3. 在远程仓库完成一个模拟提交：这时候如果直接使用 `git push` 是不能够推送到远程仓库的，因为本地的远程分支的状态与远程仓库的分支状态是不一样的

![image-20220630150647801](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630150647801.png)



4. 先使用 `git pull` 拉取远程仓库的数据并且合并到本地，然后再推送本地的数据到远程仓库 `git push`，除了使用 `git pull` 还可以使用其他的方法来完成，在这里使用  `git pull --rebase` 拉取数据后的结果如下：

![image-20220630151307329](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630151307329.png)



5. 使用 `git push` 推送本地仓库的数据到远程仓库

![image-20220630151355471](07-%E5%81%8F%E7%A6%BB%E7%9A%84%E5%B7%A5%E4%BD%9C.assets/image-20220630151355471.png)













